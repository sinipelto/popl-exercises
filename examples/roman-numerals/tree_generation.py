#!/usr/bin/env python3
# ----------------------------------------------------------------------
''' SuperSimple (and useless) unicodeLanguage. Numbers are roman numerals.
push 1 to stack, push 2 to stack, add them, print top of stack:
I⇑⍽II⇑⍽⊕⍽ψ⍽↵  
push 1 to stack, push 11 to stack, swap 1. and 2. item in stack, minus, print:
I⇑⍽XI⇑⍽↔⍽⊖⍽ψ⍽↵
push 1, 2, and 3 to stack, swap 2. and 3. elements in stack
I⇑⍽II⇑⍽III⇑⍽⟨II⍽III⍽↔⟩↵
push 2 and 1 to stack, create a copy of stack and perform addition+print,
return to original stack and perform subtraction+print
I⇑⍽II⇑⍽⟦⊕⍽ψ⟧⍽⊖⍽ψ↵
'''
# ----------------------------------------------------------------------
from ply import yacc
import tokenizer # previous phase example snippet code

import tree_print # syntax tree pretty-printer

# tokens are defined in lex-module, but needed here also in syntax rules
tokens = tokenizer.tokens

class ASTnode:
  def __init__(self, typestr):
    self.nodetype = typestr

# any funcion starting with 'p_' is PLY yacc rule
# first definition is the target we want to reduce 
# in other words: after processing all input tokens, if this start-symbol
# is the only one left, we do not have any syntax errors
def p_program1(p):
    '''program : statement'''
    p[0] = ASTnode('program')
    p[0].children_stmts = [p[1]]

def p_program2(p):
    '''program : program statement'''
    p[0] = p[1]
    p[0].children_stmts.append(p[2])


# statement can be applied to number or standalone
def p_statement1(p):
    '''statement : roman unary_op'''
    p[0] = ASTnode('unary_op')
    p[0].child_roman = p[1]
    p[0].value = p[2]
    p[0].lineno = p[1].lineno

def p_roman(p):
    '''roman : ROMAN'''
    p[0] = ASTnode('literal')
    p[0].value = p[1]
    p[0].lineno = p.lineno(1)

def p_unary_op(p):
    '''unary_op : PUSH'''
    p[0] = p[1] # Not a node, just the operator string (lexeme)

def p_statement2(p):
    '''statement : single_op
                 | complex_stmt
                 | cmd_block'''
    p[0] = p[1]

def p_single_op(p):
    '''single_op : POP
                 | SWAP
                 | ADD
                 | SUB
                 | PRINT'''
    p[0] = ASTnode(p[1])
    p[0].lineno = p.lineno(1)

def p_complex_stmt(p):
    '''complex_stmt : CMDSTART roman roman complex_op CMDEND'''
    p[0] = ASTnode('complex_stmt')
    p[0].child_idx1 = p[2]
    p[0].child_idx2 = p[3]
    p[0].child_op = p[4]
    p[0].lineno = p.lineno(1)

def p_complex_op(p):
    '''complex_op : SWAP'''
    p[0] = ASTnode(p[1])
    p[0].lineno = p.lineno(1)

def p_cmd_block(p):
    '''cmd_block : SEQSTART program SEQEND'''
    p[0] = p[2]

# error token is generated by PLY if the automation enters error state
# (cannot continue reducing or shifting)
def p_error(p):
    print( 'syntax error @', p )
    raise SystemExit

parser = yacc.yacc()

if __name__ == '__main__':
    import argparse, codecs
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('-t', '--treetype', help='type of output tree (unicode/ascii/dot)')
    group = arg_parser.add_mutually_exclusive_group()
    group.add_argument('--who', action='store_true', help='who wrote this' )
    group.add_argument('-f', '--file', help='filename to process')
    ns = arg_parser.parse_args()

    outformat="unicode"
    if ns.treetype:
      outformat = ns.treetype

    if ns.who == True:
        # identify who wrote this
        print( '88888 Ahto Simakuutio' )
    elif ns.file is None:
        # user didn't provide input filename
        arg_parser.print_help()
    else:
        data = codecs.open( ns.file, encoding='utf-8' ).read()
        result = parser.parse(data, lexer=tokenizer.lexer, debug=False)
        tree_print.treeprint(result, outformat)
